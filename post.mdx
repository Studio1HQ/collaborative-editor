# Building Real-Time Collaborative Documents with Velt.dev and Auth0 in Next.js

Real-time collaboration features have become essential in modern web applications. While services like Google Docs and Figma make it look seamless, implementing these features from scratch involves complex challenges like operational transforms, conflict resolution, and state synchronization. This tutorial demonstrates how to leverage Velt.dev's battle-tested collaboration infrastructure alongside Auth0's authentication system in a Next.js application.

We'll build a **real-time collaborative document editor** using:

- **Next.js (App Router)** - Leveraging server components and middleware for optimal performance
- **Auth0** - For robust authentication and user management
- **Velt.dev** - For real-time collaboration features

The final application will enable authenticated users to:

- Collaborate on documents with real-time synchronization
- Add contextual comments through text selection
- See other users' cursor positions in real-time
- View presence indicators with user status

## Why combine Velt.dev with Auth0 in a Next.js app?

**Next.js + Auth0** provides:

- Type-safe API routes with middleware support
- Secure session management
- Built-in OAuth flows and social login options
- Efficient server-side rendering for faster initial loads

**Velt.dev** eliminates the need to:

- Implement WebSocket connections and state sync
- Build complex conflict resolution systems
- Manage presence and cursor tracking
- Create comment threading infrastructure

## Initial Setup

### Prerequisites

Ensure you have:

- Node.js 16.8 or later
- A [Velt.dev](https://velt.dev) account (free tier works)
- An [Auth0](https://auth0.com) account
- Basic familiarity with Next.js and TypeScript

### Project Initialization

Start by creating a new Next.js project with TypeScript and the App Router:

```bash
npx create-next-app@latest collaborative-editor --typescript --app
cd collaborative-editor
```

### Dependencies

Install the required packages:

```bash
npm install @auth0/nextjs-auth0 @veltdev/react react-quill
```

These packages provide:

- `@auth0/nextjs-auth0`: Auth0's SDK with Next.js-specific optimizations
- `@veltdev/react`: Velt's React components and hooks
- `react-quill`: A lightweight rich text editor (you can swap this with any other editor)

## Auth0 Configuration

Auth0 provides a secure authentication layer with minimal setup. Here's how to configure it:

### Environment Setup

Create `.env.local` with your Auth0 credentials:

```bash
# .env.local
AUTH0_SECRET='LONG_RANDOM_STRING'
APP_BASE_URL='http://localhost:3000'
AUTH0_DOMAIN='https://YOUR_DOMAIN.auth0.com'
AUTH0_CLIENT_ID='YOUR_CLIENT_ID'
AUTH0_CLIENT_SECRET='YOUR_CLIENT_SECRET'
```

The Auth0 secret can be generated using `openssl rand -hex 32` for production environments.

### Auth0 Application Setup

To set up [Auth0](https://auth0.com/), you'll need to create an application in your Auth0 dashboard. Log in to your Auth0 dashboard and on the side panel, select **Applications** > **Applications**, then click **Create Application**. Give your application a name, choose **Regular Web Application**, and click **Create**. Then select **Next.js** as the technology.

Next, select **Settings** and copy the following values into your `.env.local`:

- **Domain**
- **Client ID**
- **Client Secret**

Make sure to set the **Allowed Callback URLs** to `http://localhost:3000/auth/callback`, and the **Allowed Logout URLs** to `http://localhost:3000`.

### Auth0 SDK Integration

Create the Auth0 client wrapper:

```ts
// lib/auth0.ts
import { Auth0Client } from "@auth0/nextjs-auth0/server";

export const auth0 = new Auth0Client();
```

This client provides methods for session management and user authentication.

### Authentication Middleware

Set up the middleware to handle auth routes:

```ts
// middleware.ts
import type { NextRequest } from "next/server";
import { auth0 } from "./lib/auth0";

export async function middleware(request: NextRequest) {
  return await auth0.middleware(request);
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)",
  ],
};
```

The matcher pattern excludes static assets while protecting all other routes.

### Home Page with Auth0

Update file `pages/index.tsx` to handle the home page with login and signup buttons:

```tsx
// pages/index.tsx
import Link from "next/link";
import React from "react";
import { useUser } from "@auth0/nextjs-auth0";

const Page = () => {
  const { user, isLoading } = useUser();

  if (!user && !isLoading) {
    return (
      <main className="min-h-screen flex flex-col items-center justify-center bg-gray-50">
        <div className="text-center space-y-8 p-8 max-w-md w-full bg-white rounded-lg shadow-lg">
          <h1 className="text-3xl font-bold text-gray-800">
            Collaborative Editor
          </h1>
          <p className="text-gray-600">
            A real-time collaborative editing platform. Work together with your
            team in real-time.
          </p>
          <div className="space-y-4">
            <Link href="/auth/login?screen_hint=signup" className="block">
              <button className="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
                Sign up
              </button>
            </Link>
            <Link href="/auth/login" className="block">
              <button className="w-full border border-gray-300 hover:border-gray-400 text-gray-700 font-medium py-2 px-4 rounded-md transition-colors">
                Log in
              </button>
            </Link>
          </div>
        </div>
      </main>
    );
  }

  return (
    <main className="min-h-screen bg-gray-50">
      <div className="max-w-4xl mx-auto p-8">
        <div className="bg-white rounded-lg shadow-lg p-6">
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-2xl font-bold text-gray-800">
              Welcome, {user?.name}!
            </h1>
            <div className="flex gap-4">
              <Link href="/editor">
                <button className="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
                  Go to Editors
                </button>
              </Link>
              <Link href="/auth/logout">
                <button className="bg-gray-100 hover:bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded-md transition-colors">
                  Log out
                </button>
              </Link>
            </div>
          </div>
          <p className="text-gray-600">
            Start collaborating on your documents in real-time.
          </p>
        </div>
      </div>
    </main>
  );
};

export default Page;
```

Running this code will give you a simple home page with options to log in or sign up. Once logged in, users will see a welcome message, a button to go to the editors page, and a logout button.

### AuthProvider Component

To protect routes and ensure only authenticated users can access certain pages, create a reusable AuthProvider component:

```tsx
// providers/AuthProvider.tsx
import { useUser } from "@auth0/nextjs-auth0";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function AuthProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const { user, isLoading } = useUser();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading && !user) {
      router.push("/");
    }
  }, [user, isLoading, router]);

  if (isLoading)
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 text-gray-700">
        Loading...
      </div>
    );

  if (!user) return null;

  return <>{children}</>;
}
```

Use this AuthProvider to wrap any page that requires authentication. For example, in your `pages/editors.tsx`, you can use it like this:

```tsx
// pages/editors.tsx
import AuthProvider from "@/providers/AuthProvider";

const Page = () => {
  return (
    <AuthProvider>
      <h1>Editor&apos;s Page</h1>
    </AuthProvider>
  );
};

export default Page;
```

This ensures that unauthenticated users are redirected to the home page where they can log in. You can test this by trying to access the `/editor` page without being logged in.

## Quill Editor Setup

To build a collaborative document editor, we need a rich text editor that supports real-time updates. For this, we will use React Quill, which is a React wrapper for the Quill rich text editor.

### Building the Editor Component



## Velt.dev Integration

Velt.dev significantly reduces the complexity of building real-time collaborative features. Instead of managing WebSocket connections, implementing CRDTs (Conflict-free Replicated Data Types), or building comment systems from scratch, Velt provides these features as composable React components.

Key benefits of using Velt include:

- Built-in conflict resolution and operational transforms
- Scalable WebSocket infrastructure
- Presence management and live cursor tracking
- Thread-based commenting system
- Automatic user state synchronization

### Velt Provider Setup

The VeltProvider component initializes the Velt client and manages the real-time connection state. Create a dedicated provider component:

```tsx
// providers/VeltReactProvider.tsx
import { VeltProvider } from "@veltdev/react";
import React from "react";

const VeltReactProvider = ({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) => {
  return (
    <VeltProvider apiKey={process.env.NEXT_PUBLIC_VELT_API_KEY!}>
      {children}
    </VeltProvider>
  );
};

export default VeltReactProvider;
```

This provider should wrap your application root to ensure Velt's features are available throughout your component tree:

```tsx
// _app.tsx
import type { AppProps } from "next/app";
import VeltReactProvider from "@/providers/VeltReactProvider";

export default function App({ Component, pageProps }: AppProps) {
  return (
    <div>
      <VeltReactProvider>
        <Component {...pageProps} />
      </VeltReactProvider>
    </div>
  );
}
```

The VeltProvider automatically handles:

- WebSocket connection management
- Real-time state synchronization
- User presence tracking
- Event propagation to child components

### Syncing Auth0 User with Velt

To ensure Velt knows who the authenticated user is, you need to pass the Auth0 user data to Velt. This is typically done in a `useEffect` hook after the user logs in.

Velt provides two ways to handle user identity:

1. **Backend Sync (REST API)**: Syncing users to Velt whenever a new user is added or removed in your Firebase app using the REST API. This method keeps a permanent record of users in Velt's database.
2. **Frontend Contact List**: Providing the contact list directly in the frontend using the `updateContactList` method. This approach is simpler for demos and smaller applications.

For our article, we'll use the second approach as it's more straightforward to implement, doesn't require backend API calls, and works perfectly for demonstration purposes.

## Document Editor Page

Create `app/editor/page.tsx`.

This page:

- Checks if the user is authenticated
- Loads the Velt provider
- Initializes collaboration features

### `app/editor/page.tsx`

```tsx
"use client";

import { useUser } from "@auth0/nextjs-auth0/client";
import { useEffect } from "react";
import { VeltProvider, VeltPresence, VeltLiveCursors, useVelt } from "velt";
import ReactQuill from "react-quill";
import "react-quill/dist/quill.snow.css";

export default function EditorPage() {
  const { user, error, isLoading } = useUser();

  useEffect(() => {
    if (user) {
      // Pass Auth0 user data to Velt for identity tracking
      window.Velt.setUser({
        userId: user.sub, // unique identifier
        name: user.name,
        avatar: user.picture,
        email: user.email,
      });
    }
  }, [user]);

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error loading user.</p>;
  if (!user) return <a href="/api/auth/login">Login</a>;

  return (
    <VeltProvider apiKey={process.env.NEXT_PUBLIC_VELT_PROJECT_ID!}>
      <div className="p-6 max-w-4xl mx-auto">
        <h1 className="text-2xl font-semibold mb-4">Shared Document</h1>

        <div className="border rounded p-4 relative">
          <ReactQuill theme="snow" />
          <VeltLiveCursors />
          <VeltPresence />
        </div>
      </div>
    </VeltProvider>
  );
}
```

### Comments Feature

To enable comments, wrap the editor component with `VeltCommentable`:

```tsx
import { VeltCommentable } from 'velt';

...

<VeltCommentable id="doc-editor">
 <ReactQuill theme="snow" />
</VeltCommentable>
```

This enables users to:

- Select text
- Right-click or click a comment icon
- Add inline comments

You can enhance this later with more sophisticated comment UIs, but this is the fastest way to get started.

### Presence & Cursors

We already added `<VeltLiveCursors />` and `<VeltPresence />`—Velt will show live cursors with user avatars, plus indicators when people enter/leave the document.

You can customize cursor color and display name via `Velt.setUser()` in your `useEffect`.

## Testing

1. Start the app:

```bash
npm run dev
```

2. Open **two separate incognito windows**, log in with different Auth0 accounts.

3. Navigate to `/editor`

You should now see:

- Each other's cursors in real time
- Presence bubbles/avatars
- Ability to comment on text
- Edits updating live

If something's not syncing, double-check:

- Your `VELT_PROJECT_ID`
- That users are successfully passed to `Velt.setUser()`
- The `VeltProvider` wraps your components properly

## Why These Choices?

**Why ReactQuill?**

- Easy to drop in a rich text editor
- Works well with Velt's comment overlays

**Why pass Auth0 data into `Velt.setUser()`?**

- Velt needs to know who each user is to track presence, comments, etc.
- We reuse the existing Auth0 identity to avoid duplicate login systems

**Why Velt for collaboration?**

- Built specifically for real-time apps
- Handles operational transforms, presence, and comments out of the box
- Abstracts away complex CRDT logic

## Production Considerations

A few quick notes for production-readiness:

- **Authentication gating:** Lock down routes on the server to prevent unauthorized access to documents
- **Data persistence:** Right now, our editor doesn't save to a backend. You'll want to connect changes to a database (e.g., via Velt's content syncing APIs or by capturing changes from the editor)
- **Rate limiting / abuse:** Be sure to throttle comment creation and document edits if your app is public
- **Role-based access:** Add permissions (e.g., read-only vs editor) based on Auth0 user roles

## Conclusion

{/* You now have a working collaborative document editor */}

With minimal setup, you've now built a fully authenticated, real-time collaborative editor using:

- **Velt.dev** for comments, presence, and cursors
- **Auth0** for authentication
- **Next.js 14+** for modern app structure

This combination is ideal for teams building productivity tools, educational platforms, or any app where real-time collaboration matters.

If you're expanding this, consider:

- Richer document structures (not just plain HTML)
- Comment threads and notifications
- Granular document access controls

Happy building!

## Resources

- [Velt.dev Docs](https://docs.velt.dev)
- [Auth0 Next.js SDK](https://auth0.com/docs/quickstart/webapp/nextjs)
- [React Quill](https://github.com/zenoamaro/react-quill)

Want the full codebase as a starter? Let me know, and I'll drop a GitHub repo or zip export.
