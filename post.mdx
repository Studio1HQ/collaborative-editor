# Building Real-Time Collaborative Documents with Velt.dev and Auth0 in Next.js

Real-time collaboration features have become essential in modern web applications. While services like Google Docs and Figma make it look seamless, implementing these features from scratch involves complex challenges like operational transforms, conflict resolution, and state synchronization. This tutorial demonstrates how to leverage Velt.dev's battle-tested collaboration infrastructure alongside Auth0's authentication system in a Next.js application.

We'll build a **real-time collaborative document editor** using:

- **Next.js (App Router)** - Leveraging server components and middleware for optimal performance
- **Auth0** - For robust authentication and user management
- **Velt.dev** - For real-time collaboration features

The final application will enable authenticated users to:

- Collaborate on documents with real-time synchronization
- Add contextual comments through text selection
- See other users' cursor positions in real-time
- View presence indicators with user status

## Why combine Velt.dev with Auth0 in a Next.js app?

**Next.js + Auth0** provides:

- Type-safe API routes with middleware support
- Secure session management
- Built-in OAuth flows and social login options
- Efficient server-side rendering for faster initial loads

**Velt.dev** eliminates the need to:

- Implement WebSocket connections and state sync
- Build complex conflict resolution systems
- Manage presence and cursor tracking
- Create comment threading infrastructure

## Initial Setup

### Prerequisites

Ensure you have:

- Node.js 16.8 or later
- A [Velt.dev](https://velt.dev) account (free tier works)
- An [Auth0](https://auth0.com) account
- Basic familiarity with Next.js and TypeScript

### Project Initialization

Start by creating a new Next.js project with TypeScript and the App Router:

```bash
npx create-next-app@latest collaborative-editor --typescript --app
cd collaborative-editor
```

### Dependencies

Install the required packages:

```bash
npm install @auth0/nextjs-auth0 @veltdev/react react-quill
```

These packages provide:

- `@auth0/nextjs-auth0`: Auth0's SDK with Next.js-specific optimizations
- `@veltdev/react`: Velt's React components and hooks
- `react-quill`: A lightweight rich text editor (you can swap this with any other editor)

## Auth0 Configuration

Auth0 provides a secure authentication layer with minimal setup. Here's how to configure it:

### Environment Setup

Create `.env.local` with your Auth0 credentials:

```bash
# .env.local
AUTH0_SECRET='LONG_RANDOM_STRING'
APP_BASE_URL='http://localhost:3000'
AUTH0_DOMAIN='https://YOUR_DOMAIN.auth0.com'
AUTH0_CLIENT_ID='YOUR_CLIENT_ID'
AUTH0_CLIENT_SECRET='YOUR_CLIENT_SECRET'
```

The Auth0 secret can be generated using `openssl rand -hex 32` for production environments.

### Auth0 Application Setup

To set up [Auth0](https://auth0.com/), you'll need to create an application in your Auth0 dashboard. Log in to your Auth0 dashboard and on the side panel, select **Applications** > **Applications**, then click **Create Application**. Give your application a name, choose **Regular Web Application**, and click **Create**. Then select **Next.js** as the technology.

Next, select **Settings** and copy the following values into your `.env.local`:

- **Domain**
- **Client ID**
- **Client Secret**

Make sure to set the **Allowed Callback URLs** to `http://localhost:3000/auth/callback`, and the **Allowed Logout URLs** to `http://localhost:3000`.

### Auth0 SDK Integration

Create the Auth0 client wrapper:

```ts
// lib/auth0.ts
import { Auth0Client } from "@auth0/nextjs-auth0/server";

export const auth0 = new Auth0Client();
```

This client provides methods for session management and user authentication.

### Authentication Middleware

Set up the middleware to handle auth routes:

```ts
// middleware.ts
import type { NextRequest } from "next/server";
import { auth0 } from "./lib/auth0";

export async function middleware(request: NextRequest) {
  return await auth0.middleware(request);
}

export const config = {
  matcher: [
    "/((?!_next/static|_next/image|favicon.ico|sitemap.xml|robots.txt).*)",
  ],
};
```

The matcher pattern excludes static assets while protecting all other routes.

### Home Page with Auth0

Update file `pages/index.tsx` to handle the home page with login and signup buttons:

```tsx
// pages/index.tsx
import Link from "next/link";
import React from "react";
import { useUser } from "@auth0/nextjs-auth0";

const Page = () => {
  const { user, isLoading } = useUser();

  if (!user && !isLoading) {
    return (
      <main className="min-h-screen flex flex-col items-center justify-center bg-gray-50">
        <div className="text-center space-y-8 p-8 max-w-md w-full bg-white rounded-lg shadow-lg">
          <h1 className="text-3xl font-bold text-gray-800">
            Collaborative Editor
          </h1>
          <p className="text-gray-600">
            A real-time collaborative editing platform. Work together with your
            team in real-time.
          </p>
          <div className="space-y-4">
            <Link href="/auth/login?screen_hint=signup" className="block">
              <button className="w-full bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
                Sign up
              </button>
            </Link>
            <Link href="/auth/login" className="block">
              <button className="w-full border border-gray-300 hover:border-gray-400 text-gray-700 font-medium py-2 px-4 rounded-md transition-colors">
                Log in
              </button>
            </Link>
          </div>
        </div>
      </main>
    );
  }

  return (
    <main className="min-h-screen bg-gray-50">
      <div className="max-w-4xl mx-auto p-8">
        <div className="bg-white rounded-lg shadow-lg p-6">
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-2xl font-bold text-gray-800">
              Welcome, {user?.name}!
            </h1>
            <div className="flex gap-4">
              <Link href="/editor">
                <button className="bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded-md transition-colors">
                  Go to Editors
                </button>
              </Link>
              <Link href="/auth/logout">
                <button className="bg-gray-100 hover:bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded-md transition-colors">
                  Log out
                </button>
              </Link>
            </div>
          </div>
          <p className="text-gray-600">
            Start collaborating on your documents in real-time.
          </p>
        </div>
      </div>
    </main>
  );
};

export default Page;
```

Running this code will give you a simple home page with options to log in or sign up. Once logged in, users will see a welcome message, a button to go to the editors page, and a logout button.

### AuthProvider Component

To protect routes and ensure only authenticated users can access certain pages, create a reusable AuthProvider component:

```tsx
// providers/AuthProvider.tsx
import { useUser } from "@auth0/nextjs-auth0";
import { useRouter } from "next/navigation";
import { useEffect } from "react";

export default function AuthProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const { user, isLoading } = useUser();
  const router = useRouter();

  useEffect(() => {
    if (!isLoading && !user) {
      router.push("/");
    }
  }, [user, isLoading, router]);

  if (isLoading)
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50 text-gray-700">
        Loading...
      </div>
    );

  if (!user) return null;

  return <>{children}</>;
}
```

Use this AuthProvider to wrap any page that requires authentication. For example, in your `pages/editor.tsx`, you can use it like this:

```tsx
// pages/editor.tsx
import AuthProvider from "@/providers/AuthProvider";

const Page = () => {
  return (
    <AuthProvider>
      <h1>Editor&apos;s Page</h1>
    </AuthProvider>
  );
};

export default Page;
```

This ensures that unauthenticated users are redirected to the home page where they can log in. You can test this by trying to access the `/editor` page without being logged in.

## Velt.dev Integration

Velt.dev significantly reduces the complexity of building real-time collaborative features. Instead of managing WebSocket connections, implementing CRDTs (Conflict-free Replicated Data Types), or building comment systems from scratch, Velt provides these features as composable React components.

Key benefits of using Velt include:

- Built-in conflict resolution and operational transforms
- Scalable WebSocket infrastructure
- Presence management and live cursor tracking
- Thread-based commenting system
- Automatic user state synchronization

### Velt Provider Setup

The VeltProvider component initializes the Velt client and manages the real-time connection state. Create a dedicated provider component:

```tsx
// providers/VeltReactProvider.tsx
import { VeltProvider } from "@veltdev/react";
import React from "react";

const VeltReactProvider = ({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) => {
  return (
    <VeltProvider apiKey={process.env.NEXT_PUBLIC_VELT_API_KEY!}>
      {children}
    </VeltProvider>
  );
};

export default VeltReactProvider;
```

This provider should wrap your application root to ensure Velt's features are available throughout your component tree:

```tsx
// _app.tsx
import type { AppProps } from "next/app";
import VeltReactProvider from "@/providers/VeltReactProvider";

export default function App({ Component, pageProps }: AppProps) {
  return (
    <div>
      <VeltReactProvider>
        <Component {...pageProps} />
      </VeltReactProvider>
    </div>
  );
}
```

The VeltProvider automatically handles:

- WebSocket connection management
- Real-time state synchronization
- User presence tracking
- Event propagation to child components

### Syncing Auth0 User with Velt

To ensure Velt knows who the authenticated user is, you need to sync Auth0 user data to Velt. We'll use Velt's **Backend Sync (REST API)**: whenever a user logs in, we send their profile to Velt's backend using their REST API. This keeps a permanent record of users in Velt's database and is suitable for production use.

To automate this, let's create a custom React hook (e.g., `useVeltAuth`) that calls the Velt REST API with the Auth0 user's info. This hook will be typically invoked immesiate ly after the user logs in, ensuring their data is always up-to-date in Velt. For this example, we will call it in the hoke page as that is where the user is authenticated.

**Example usage:**

```tsx
// hooks/useVeltAuth.ts
import { useUser } from "@auth0/nextjs-auth0";
import { useIdentify } from "@veltdev/react";

export default function useVeltAuth() {
  const { user: auth0User } = useUser();

  const veltUser = auth0User
    ? {
        userId: auth0User.sub || "",
        name: auth0User.name || "",
        email: auth0User.email || "",
        photoUrl: auth0User.picture || "",
        organizationId: "collaborative-editor",
        color: "#FF0000",
        textColor: "#FFFFFF",
      }
    : null;

  useIdentify(veltUser);

  if (!auth0User) return;
}
```

You can then call `useVeltAuth()` in your home page or any protected page to ensure the user is synced with Velt:

```tsx
// pages/index.tsx
import useVeltAuth from "@/hooks/useVeltAuth";

const Page = () => {
  useVeltAuth();
  // ...existing code...
};
```

This approach ensures that every authenticated user is registered in Velt's backend, enabling robust collaboration features and user management.

## Quill Editor Setup

To build a collaborative document editor, we need a rich text editor that supports real-time updates. For this, we will use React Quill, which is a React wrapper for the Quill rich text editor.

### Building the Editor Component

Let's break down the main components that make up our collaborative editor:

#### 1. UserDropdown Component

This component displays the current user's name (or email) and provides a dropdown menu for navigation and logout. It uses Auth0's `useUser` hook to access user information.

```tsx
// components/UserDropdown.tsx
import React, { useState } from "react";
import Link from "next/link";
import { useUser } from "@auth0/nextjs-auth0";

const UserDropdown = () => {
  const { user } = useUser();

  const [open, setOpen] = useState(false);

  return (
    <div className="relative inline-block text-left">
      <button
        onClick={() => setOpen(v => !v)}
        className="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-md shadow-sm text-gray-700 font-medium">
        <span className="font-semibold">{user?.name || user?.email}</span>
        <svg
          className="w-4 h-4"
          fill="none"
          stroke="currentColor"
          strokeWidth={2}
          viewBox="0 0 24 24">
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            d="M19 9l-7 7-7-7"
          />
        </svg>
      </button>
      {open && (
        <div className="absolute right-0 mt-2 w-40 bg-white border border-gray-200 rounded-md shadow-lg z-10">
          <Link
            href="/"
            className="block w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">
            Home
          </Link>
          <Link href="/auth/logout" className="block">
            <button className="w-full text-left px-4 py-2 text-gray-700 hover:bg-gray-100">
              Log out
            </button>
          </Link>
        </div>
      )}
    </div>
  );
};

export default UserDropdown;
```

#### 2. RichTextEditor Component

This component provides a rich text editor (using React Quill) and a live preview. We will integrate it with Velt later on for real-time collaboration.

```tsx
// components/RichTextEditor.tsx
import React, { useState } from "react";
import dynamic from "next/dynamic";

const ReactQuill = dynamic(() => import("react-quill"), { ssr: false });
import "react-quill/dist/quill.snow.css";

const RichTextEditor = () => {
  const [value, setValue] = useState("");

  return (
    <div className="flex flex-col md:flex-row gap-8 mt-8 h-[calc(100vh-8rem)]">
      <section className="flex-1 md:w-[50%] bg-white rounded-lg shadow-lg p-6 flex flex-col">
        <h2 className="text-lg font-semibold mb-4 text-gray-700">Editor</h2>
        <div className="flex-1 max-h-full overflow-auto">
          <ReactQuill
            theme="snow"
            value={value}
            onChange={setValue}
            style={{ height: "100%" }}
          />
        </div>
      </section>
      <section className="flex-1  md:w-[50%] bg-white rounded-lg shadow-lg p-6 flex flex-col">
        <h2 className="text-lg font-semibold mb-4 text-gray-700">Preview</h2>
        <div className="flex-1 min-h-0 max-h-full overflow-auto max-w-none border-2 p-4 rounded-sm border-gray-200">
          <div
            className="editor-output"
            dangerouslySetInnerHTML={{ __html: value }}
          />
        </div>
      </section>
    </div>
  );
};

export default RichTextEditor;
```

#### 3. Editor Page

The editor page brings everything together. It protects the route with `AuthProvider`, displays the user dropdown, and renders the rich text editor.

```tsx
// pages/editor.tsx
import React from "react";
import AuthProvider from "@/providers/AuthProvider";
import RichTextEditor from "@/components/RichTextEditor";
import UserDropdown from "@/components/UserDropdown";

const Page = () => {
  return (
    <AuthProvider>
      <main className="min-h-screen bg-gray-50 py-10">
        <div className="container mx-auto px-4">
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-3xl font-extrabold text-blue-700 drop-shadow">
              Shared Document Editor
            </h1>
            <UserDropdown />
          </div>
          <RichTextEditor />
        </div>
      </main>
    </AuthProvider>
  );
};
export default Page;
```

With these components, you have a modular, collaborative editor interface ready for real-time features and user management.

## Adding Real-Time Collaboration with Velt

Now that we have a basic editor setup, let's integrate Velt.dev to enable real-time collaboration features like live comments, and presence tracking.

### Identify the current user with Velt

To identify the current user in Velt, you can use the `useVeltClient()` method. This should be done after the user is authenticated and you have their information.

```tsx
// components/RichTextEditor.tsx
import { useEffect } from "react";
import { useUser } from "@auth0/nextjs-auth0";
import { useVeltClient } from "@veltdev/react";

const { user: auth0User } = useUser();
const { client } = useVeltClient();

useEffect(() => {
  const veltUser = auth0User
    ? {
        userId: auth0User.sub || "",
        name: auth0User.name || "",
        email: auth0User.email || "",
        photoUrl: auth0User.picture || "",
        organizationId: "collaborative-editor",
        color: "#FF0000",
        textColor: "#FFFFFF",
      }
    : null;

  const initVelt = async () => {
    if (client && veltUser) {
      await client.identify(veltUser);
    }
  };

  initVelt().catch(console.error);
}, [client, auth0User]);
```

### Set up the document ID for comments

A document in Velt is a shared space where users can collaborate in real-time. To enable comments and real-time updates, we need to define a unique document ID. This ID will be used by Velt to track changes and comments for this specific document.

```tsx
// components/RichTextEditor.tsx
useEffect(() => {
  if (client) {
    client.setDocument("collaborative-post", {
      documentName: "Welcome to the Collaborative Editor",
    });
  }
}, [client]);
```

### Adding Comments, Presence and Notifications

Velt provides built-in support for comments, presence, and notifications. They provide you with different components to handle these features easily. For our editor, we will be using the following components:

- VeltNotificationsTool: This displays real-time notifications for comments and mentions.
- VeltCommentTool: This allows users to add comments on selected text.
- VeltComments: This displays all the comments on the document.
- VeltPresence: This shows the avatars for users currently collaborating on the document.
- VeltSidebarButton: This is a button to toggle the comments sidebar.
- VeltCommentsSidebar: This displays the comments sidebar with all comments and allows users to reply to comments.

It is important to note that you have to enable notifications in your console for the VeltNotificationsTool to work. You can do that by going to the "In-app Notifications" section in your Velt dashboard, then enable notifications for your application. Feel. free to customize it to your liking.

Now, let's integrate these components into our `editor` page:

```tsx
// pages/editor.tsx
import {
  VeltNotificationsTool,
  VeltCommentTool,
  VeltComments,
  VeltPresence,
  VeltSidebarButton,
  VeltCommentsSidebar,
} from "@veltdev/react";

const Page = () => {
  return (
    <AuthProvider>
      <main className="min-h-screen bg-gray-50 py-10">
        <div className="container mx-auto px-4">
          <div className="flex flex-col gap-y-3 gap-x-6 md:flex-row justify-between items-start mb-6">
            <div>
              <h1 className="text-3xl font-extrabold text-blue-700 drop-shadow">
                Shared Document Editor
              </h1>
              <div className="flex items-center justify-start mb-4">
                <p className="mr-2 font-semibold text-gray-600">Viewers:</p>
                <VeltPresence />
              </div>
            </div>
            <div className="flex justify-end items-center space-x-4">
              <VeltCommentTool />
              <VeltNotificationsTool />
              <UserDropdown />
            </div>
          </div>
          <RichTextEditor />
        </div>

        <div className="fixed bottom-10 right-10 z-50 space-y-4">
          <VeltSidebarButton />
          <VeltCommentsSidebar pageMode={true} />
          <VeltComments />
        </div>
      </main>
    </AuthProvider>
  );
};
export default Page;
```

## Testing the Collaborative Editor

To test the features we just implemented, lets go to the `/editor` page and ensure everything is working as expected.

1. Start your Next.js app:

```bash
npm run dev
```

2. Open your browser and navigate to `http://localhost:3000`.
3. Open **two separate incognito windows**, log in with different Auth0 accounts.
4. Navigate to `/editor`

You should now see:

- both user's avatar icons in the top left corner of the page
- the rich text editor where both users can type and see each other's changes in real-time
- the comments tool that allows users to select text and add comments
- the notifications tool that shows real-time notifications for comments and mentions
- the comments sidebar that displays all comments and allows users to reply to them

5. Try selecting text and adding comments. You should see the comments appear in real-time for both users.
6. Check the notifications tool to see if you receive notifications for comments and mentions.

Because Velt handles the real-time updates, presence, and comments, you don't need to worry about implementing these features from scratch. Velt takes care of the heavy lifting, allowing you to focus on building your application.

## Next Steps

Now that you have a basic collaborative editor with real-time features, you can consider the following enhancements:

- **Backend Sync**: Currently, when one user makes changes to the document, those changes are not persisted or shared with other users. You can implement a backend sync mechanism to save the document state to a database.
- **Advanced Text Editor**: Currently, we are using a basic rich text editor. You can enhance it with more features like image uploads, formatting options, and more.
- **Markdown Support**: If you want to support Markdown or other text formats, you can integrate a library that converts between rich text and Markdown.
- **Follow Mode**: Implement a follow mode where one user can follow another user's cursor in real-time, similar to how Google Docs works.
- **Document History**: Implement a version history feature that allows users to view and revert to previous versions of the document.
- **User Roles and Permissions**: Implement user roles and permissions to control who can edit, comment, or view the document.

## Conclusion

In this tutorial, we built a real-time collaborative document editor using Next.js, Auth0, and Velt.dev. We covered how to set up authentication with Auth0, integrate Velt for real-time collaboration, and create a rich text editor with comments and presence features.

By leveraging Velt.dev's infrastructure, we avoided the complexities of building real-time collaboration features from scratch, allowing us to focus on building a great user experience.

This setup provides a solid foundation for building collaborative applications, and you can extend it further based on your requirements. Whether you're building a simple note-taking app or a complex document editor, Velt.dev and Auth0 make it easier to implement real-time collaboration features without reinventing the wheel.

You can find the full codebase on GitHub to get started quickly. Feel free to customize the editor, add more features, and make it your own!
